<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Halısaha Turnuva Yönetimi (Fikstür + Drag&Drop)</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body { background: #f3f4f6; }
    .halisaha { background: linear-gradient(to bottom, #1e7a34 0%, #2aa14a 100%); border-radius: 10px; }
    .draggable-player { cursor: grab; touch-action: none; }
    .draggable-player:active { cursor: grabbing; transform: scale(1.03); }
    @media print {
      .no-print { display:none !important; }
    }
  </style>
</head>
<body class="p-4">
  <div id="root"></div>

  <script type="text/babel">
  const { useState, useEffect, useRef, useMemo } = React;

  // --- constants (same as original)
  const POSITIONS = [
    { value: "GK", label: "Kaleci" },
    { value: "DEF", label: "Defans" },
    { value: "MID", label: "Orta Saha" },
    { value: "FWD", label: "Forvet" },
  ];

  const defaultPlayers = Array.from({ length: 9 }).map((_, i) => ({
    id: i + 1,
    name: "",
    pos: i === 0 ? "GK" : i < 3 ? "DEF" : i < 6 ? "MID" : "FWD",
    starter: i < 7,
  }));

  function uid() { return Math.random().toString(36).slice(2,9); }

  function useLocalStorage(key, initial) {
    const [state, setState] = useState(() => {
      try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : initial; } catch { return initial; }
    });
    useEffect(()=>{ try { localStorage.setItem(key, JSON.stringify(state)); } catch{} }, [key, state]);
    return [state, setState];
  }

  // --- App
  function App(){
    // core data (teams)
    const [teams, setTeams] = useLocalStorage("halisaha_teams", []);
    const [editing, setEditing] = useState(null);
    const [form, setForm] = useState(()=>({ id:null, name:"", color:"#ef4444", players: JSON.parse(JSON.stringify(defaultPlayers)) }));

    // fixtures (user chooses): number of slots = floor(teams.length/2)
    const [fixtures, setFixtures] = useLocalStorage("halisaha_fixtures", []);
    // list of matches derived from fixtures (after user selects both teams)
    const [matches, setMatches] = useLocalStorage("halisaha_matches", []);
    // active match index (in matches array)
    const [activeMatchIdx, setActiveMatchIdx] = useLocalStorage("halisaha_active_match_idx", null);

    // positions per match (persisted) => key 'match-<index>' map of idKey -> {x,y}
    const [matchPositions, setMatchPositions] = useLocalStorage("halisaha_match_positions", {});

    // state for score management
    const [showScoreInput, setShowScoreInput] = useState(false);
    const [showScoreDisplay, setShowScoreDisplay] = useState(false);
    const [scores, setScores] = useLocalStorage("halisaha_scores", {});

    // refs for dragging
    const dragState = useRef({ active:false, idKey:null, startX:0, startY:0, origX:0, origY:0, rect:null });

    // sync fixtures length when team count changes
    useEffect(()=>{
      const needed = Math.floor(teams.length / 2);
      if (needed <= 0) { setFixtures([]); setMatches([]); setActiveMatchIdx(null); return; }
      setFixtures(prev => {
        // keep existing and expand/cut to needed
        const copy = Array.from({length:needed}, (_,i) => prev[i] ? prev[i] : { a:null, b:null });
        return copy;
      });
    }, [teams.length]);

    // helper reset form
    useEffect(()=>{ if (editing){ const t = teams.find(x=>x.id===editing); if (t) setForm(JSON.parse(JSON.stringify(t))); } else resetForm(); }, [editing]);

    function resetForm(){ setForm({ id:null, name:"", color:"#ef4444", players: JSON.parse(JSON.stringify(defaultPlayers)) }); }

    function saveTeam(){
      if (!form.name.trim()){ alert("Takım adı boş olamaz"); return; }
      if (teams.length >= 16 && !editing){ alert("Maksimum 16 takıma ulaşıldı"); return; }
      const payload = JSON.parse(JSON.stringify(form));
      if (!payload.id) payload.id = uid();
      payload.players = payload.players.slice(0,9).map((p, idx)=>({
        id: p.id || idx+1,
        name: p.name || `Oyuncu ${idx+1}`,
        pos: p.pos || (idx===0?"GK":idx<3?"DEF":idx<6?"MID":"FWD"),
        starter: !!p.starter,
      }));
      setTeams(prev => {
        const i = prev.findIndex(t=>t.id===payload.id);
        if (i >= 0){ const cp=[...prev]; cp[i]=payload; return cp; }
        return [...prev, payload];
      });
      setEditing(null); resetForm();
    }

    function deleteTeam(id){
      if (!confirm("Bu takımı silmek istediğinize emin misiniz?")) return;
      setTeams(prev => prev.filter(t=>t.id!==id));
      // also clear fixtures where used
      setFixtures(prev => prev.map(f => ({ a: f.a===id?null: f.a, b: f.b===id?null: f.b })));
      // remove matches that include it
      setMatches(prev => prev.filter(m => m.a !== id && m.b !== id));
      if (activeMatchIdx !== null){
        const m = matches[activeMatchIdx];
        if (m && (m.a === id || m.b === id)) setActiveMatchIdx(null);
      }
    }

    // create matches from fixtures (after user config)
    function buildMatchesFromFixtures(){
      const newMatches = fixtures.map(f => ({ a: f.a, b: f.b })).filter(m => m.a && m.b);
      setMatches(newMatches);
      // if activeMatchIdx out of range, reset
      if (activeMatchIdx !== null && activeMatchIdx >= newMatches.length) setActiveMatchIdx(null);
    }

    // when user clicks a match in list, set activeMatch and ensure positions initialised
    function openMatchByIndex(i){
      if (!matches[i]) return;
      setActiveMatchIdx(i);
      const key = `match-${i}`;
      setMatchPositions(prev => {
        if (prev[key]) return prev; // already has positions
        // initialize positions from default formation (use earlier algorithm)
        const { a, b } = matches[i];
        const teamA = teams.find(t=>t.id===a);
        const teamB = teams.find(t=>t.id===b);
        const init = {};
        if (teamA) assignInitialPositionsForTeam(init, 'A', teamA, true);
        if (teamB) assignInitialPositionsForTeam(init, 'B', teamB, false);
        return { ...prev, [key]: init };
      });
    }

    // helper to assign initial coords like original
    function assignInitialPositionsForTeam(store, sideKey, team, isLeft){
      if (!team) return;
      const starters = team.players.filter(p=>p.starter).slice(0,7);
      const coords = getDefaultFormationPositions(isLeft);
      const grouped = { GK:[], DEF:[], MID:[], FWD:[] };
      starters.forEach(s => grouped[s.pos && grouped.hasOwnProperty(s.pos) ? s.pos : 'MID'].push(s));
      if (grouped.GK[0]) store[`${sideKey}-${grouped.GK[0].id}`] = coords.GK;
      grouped.DEF.slice(0,2).forEach((p,i)=> store[`${sideKey}-${p.id}`] = coords.DEF[i] || coords.DEF[0]);
      grouped.MID.slice(0,3).forEach((p,i)=> store[`${sideKey}-${p.id}`] = coords.MID[i] || coords.MID[1]);
      if (grouped.FWD[0]) store[`${sideKey}-${grouped.FWD[0].id}`] = coords.FWD;
    }

    function getDefaultFormationPositions(isLeft){
      return {
        GK: { x: isLeft ? 120 : 880, y: 300 },
        DEF: [ { x: isLeft ? 220 : 780, y: 200 }, { x: isLeft ? 220 : 780, y: 400 } ],
        MID: [ { x: isLeft ? 400 : 600, y: 160 }, { x: isLeft ? 420 : 580, y: 300 }, { x: isLeft ? 400 : 600, y: 440 } ],
        FWD: { x: isLeft ? 520 : 480, y: 300 },
      };
    }

    // pointer-based drag handlers for SVG elements representing players
    function pointerDownHandler(e, idKey){
      e.preventDefault();
      const container = e.currentTarget.ownerSVGElement || e.currentTarget.closest('svg');
      if(!container) return;
      const rect = container.getBoundingClientRect();
      // record start
      dragState.current = {
        active: true,
        idKey,
        startX: e.clientX,
        startY: e.clientY,
        origX: (currentPositions()[idKey] || {x:0}).x,
        origY: (currentPositions()[idKey] || {y:0}).y,
        svgRect: rect,
      };
      window.addEventListener('pointermove', pointerMove);
      window.addEventListener('pointerup', pointerUp);
    }

    function pointerMove(e){
      if (!dragState.current.active) return;
      const s = dragState.current;
      const dx = ( (e.clientX - s.startX) / s.svgRect.width ) * 1000;
      const dy = ( (e.clientY - s.startY) / s.svgRect.height ) * 600;
      let nx = s.origX + dx;
      let ny = s.origY + dy;
      // clamp
      nx = Math.max(26, Math.min(1000-26, nx));
      ny = Math.max(26, Math.min(600-26, ny));
      // set position in matchPositions for active match
      if (activeMatchIdx === null) return;
      const key = `match-${activeMatchIdx}`;
      setMatchPositions(prev => {
        const copy = {...prev};
        copy[key] = copy[key] || {};
        copy[key][s.idKey] = { x: nx, y: ny };
        return copy;
      });
    }

    function pointerUp(){
      dragState.current = { active:false, idKey:null };
      window.removeEventListener('pointermove', pointerMove);
      window.removeEventListener('pointerup', pointerUp);
    }

    function currentPositions(){ return (matchPositions[`match-${activeMatchIdx}`] || {}); }

    // helper renderers (kept visually like original)
    function renderPlayerCircle(player, cx, cy, color, sideKey){
      const textY = cy + 5;
      const idKey = `${sideKey}-${player.id}`;
      // attach pointerdown to circle group
      return (
        <g key={idKey} className="draggable-player" onPointerDown={(e)=>pointerDownHandler(e, idKey)} style={{ touchAction:'none' }}>
          <circle cx={cx} cy={cy} r={28} fill={color} stroke="#ffffff" strokeWidth={2} />
          <text x={cx} y={textY} textAnchor="middle" fontSize={11} fill="#fff" fontWeight={700}>
            {player.name ? shortName(player.name) : "-"}
          </text>
        </g>
      );
    }

    function renderTeamOnPitchFromMatch(team, isLeft, sideKey){
      if (!team) return null;
      const starters = team.players.filter(p=>p.starter).slice(0,7);
      const grouped = { GK:[], DEF:[], MID:[], FWD:[] };
      starters.forEach(s => { const pos = (s.pos && grouped.hasOwnProperty(s.pos)) ? s.pos : 'MID'; grouped[pos].push(s); });
      const defaultPositions = getDefaultFormationPositions(isLeft);
      const posMap = currentPositions();

      const elems = [];

      // GK
      if (grouped.GK[0]){
        const p = grouped.GK[0];
        const idKey = `${sideKey}-${p.id}`;
        const pos = posMap[idKey] || p.customPosition || defaultPositions.GK;
        elems.push(renderPlayerCircle(p, pos.x, pos.y, team.color, sideKey));
      }
      // DEF
      grouped.DEF.slice(0,2).forEach((p,i)=>{
        const idKey = `${sideKey}-${p.id}`;
        const pos = posMap[idKey] || p.customPosition || (defaultPositions.DEF[i] || defaultPositions.DEF[0]);
        elems.push(renderPlayerCircle(p, pos.x, pos.y, team.color, sideKey));
      });
      // MID
      grouped.MID.slice(0,3).forEach((p,i)=>{
        const idKey = `${sideKey}-${p.id}`;
        const pos = posMap[idKey] || p.customPosition || (defaultPositions.MID[i] || defaultPositions.MID[1]);
        elems.push(renderPlayerCircle(p, pos.x, pos.y, team.color, sideKey));
      });
      // FWD
      if (grouped.FWD[0]){
        const p = grouped.FWD[0];
        const idKey = `${sideKey}-${p.id}`;
        const pos = posMap[idKey] || p.customPosition || defaultPositions.FWD;
        elems.push(renderPlayerCircle(p, pos.x, pos.y, team.color, sideKey));
      }
      return elems;
    }

    function shortName(name){
      if (!name) return "-";
      const parts = name.trim().split(/\s+/);
      if (parts.length === 1) return parts[0].slice(0,10);
      return (parts[0] + " " + parts[parts.length-1]).slice(0,12);
    }

    // export / import
    function exportAll(){
      const payload = { teams, fixtures, matches, matchPositions, scores };
      const blob = new Blob([JSON.stringify(payload,null,2)], { type:'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'halisaha_export.json'; a.click(); URL.revokeObjectURL(url);
    }
    function importAll(e){
      const f = e.target.files[0]; if (!f) return;
      const r = new FileReader(); r.onload = ()=>{ try{
        const json = JSON.parse(r.result);
        if (Array.isArray(json.teams)) setTeams(json.teams);
        if (Array.isArray(json.fixtures)) setFixtures(json.fixtures);
        if (Array.isArray(json.matches)) setMatches(json.matches);
        if (json.matchPositions) setMatchPositions(json.matchPositions);
        if (json.scores) setScores(json.scores);
        alert('Yüklendi');
      } catch(err){ alert('Hata: ' + err.message); } }; r.readAsText(f);
    }

    // UI: build fixture controls when number of fixtures changes
    useEffect(()=>{
      // ensure fixtures array length maintained by earlier effect — but ensure data shape
      setFixtures(prev => prev.map(x => ({ a: x.a || null, b: x.b || null })));
    }, []);

    // render
    // compute match objects (with team data) for match list
    const matchObjects = matches.map((m, idx) => {
      const a = teams.find(t=>t.id===m.a) || null;
      const b = teams.find(t=>t.id===m.b) || null;
      return { idx, a, b };
    });

    // Score handlers
    const numberOfMatchesPerTeam = teams.length > 0 ? teams.length - 1 : 0;
    
    function handleScoreChange(teamId, matchIndex, value) {
        // Negatif değerleri engellemek için kontrol
        const nonNegativeValue = Math.max(0, parseInt(value, 10) || 0);

        setScores(prev => {
            const newScores = { ...prev };
            if (!newScores[teamId]) {
                newScores[teamId] = {};
            }
            newScores[teamId][matchIndex] = nonNegativeValue;
            return newScores;
        });
    }


    // JSX
    return (
      <div className="max-w-9xl mx-auto space-y-6">
        <header className="mb-6">
          <h1 className="text-2xl font-bold text-gray-800">Halısaha Turnuva Yönetimi</h1>
          <p className="text-sm text-gray-600">Orijinal arayüz korunarak fikstür editör ve maç-listesi eklendi. Oyuncular sürüklenebilir (maç bazında kaydedilir).</p>
          <div className="mt-4 no-print">
            <button className="px-3 py-1 bg-purple-600 text-white rounded text-sm mr-2" onClick={() => { setShowScoreInput(true); setShowScoreDisplay(false); }}>Takım Puan Gir</button>
            <button className="px-3 py-1 bg-orange-600 text-white rounded text-sm" onClick={() => { setShowScoreDisplay(true); setShowScoreInput(false); }}>Puanları Görüntüle</button>
          </div>
        </header>

        <div className="flex gap-6" style={{height:"100vh"}}>
         <section className="w-[33%] bg-white p-4 rounded shadow">
            <h2 className="font-semibold mb-2">Takım Ekle / Düzenle</h2>
            <label className="block text-sm text-gray-600">Takım Adı</label>
            <input value={form.name} onChange={e=>setForm({...form, name:e.target.value})} className="w-full border rounded px-2 py-1 mb-2" />
            <label className="block text-sm text-gray-600">Takım Rengi</label>
            <input type="color" value={form.color} onChange={e=>setForm({...form, color:e.target.value})} className="w-16 h-10 p-0 mb-3" />
            <div className="text-sm font-medium mb-1 text-gray-700">Oyuncular (7 asıl + 2 yedek)</div>
            <div className="space-y-2 max-h-100 overflow-auto">
              {form.players.map((p,i)=>(
                <div key={i} className="flex gap-2 items-center">
                  <div className="w-6 text-xs text-gray-500">{i+1}.</div>
                  <input className="flex-1 border rounded px-2 py-1 text-sm" value={p.name} onChange={e=>{ const players=[...form.players]; players[i].name=e.target.value; setForm({...form, players}); }} placeholder={`Oyuncu ${i+1}`} />
                  <select className="border rounded px-2 py-1 text-sm" value={p.pos} onChange={e=>{ const players=[...form.players]; players[i].pos=e.target.value; setForm({...form, players}); }}>
                    {POSITIONS.map(pos => <option key={pos.value} value={pos.value}>{pos.label}</option>)}
                  </select>
                  <label className="text-xs flex items-center gap-1 text-gray-600"><input type="checkbox" checked={p.starter} onChange={e=>{ const players=[...form.players]; players[i].starter=e.target.checked; setForm({...form, players}); }} /> Asıl</label>
                </div>
              ))}
            </div>
            <div className="flex gap-2 mt-3">
              <button className="px-3 py-1 bg-green-600 text-white rounded text-sm" onClick={saveTeam}>Kaydet</button>
              <button className="px-3 py-1 bg-gray-200 rounded text-sm" onClick={()=>{ setEditing(null); resetForm(); }}>Yeni</button>
              <button className="px-3 py-1 bg-blue-600 text-white rounded text-sm" onClick={exportAll}>Dışa Aktar</button>
              <label className="px-3 py-1 bg-yellow-400 rounded text-sm cursor-pointer">
                İçe Aktar
                <input type="file" className="hidden" onChange={importAll} accept="application/json" />
              </label>
            </div>
          </section>

          {/* Middle-left: Team list (with edit/delete) */}
           <section className="w-[33%] bg-white p-4 rounded shadow">
            <h2 className="font-semibold mb-2">Takımlar (maks 16)</h2>
            <div className="space-y-2 max-h-100 overflow-auto">
              {teams.length === 0 && <div className="text-sm text-gray-500">Henüz takım yok. Sol bölümden ekleyin.</div>}
              {teams.map(t=>(
                <div key={t.id} className="flex items-center justify-between border rounded px-2 py-2">
                  <div className="flex items-center gap-3">
                    <input type="checkbox" checked={false} readOnly className="hidden" />
                    <div className="w-3 h-3 rounded" style={{ backgroundColor: t.color }}></div>
                    <div>
                      <div className="font-medium text-sm">{t.name}</div>
                      <div className="text-xs text-gray-500">{t.players.slice(0,7).map(p=>p.name).join(", ")}</div>
                    </div>
                  </div>
                  <div className="flex gap-1">
                    <button className="text-xs bg-sky-600 text-white px-2 rounded" onClick={()=>setEditing(t.id)}>Düzenle</button>
                    <button className="text-xs bg-red-500 text-white px-2 rounded" onClick={()=>deleteTeam(t.id)}>Sil</button>
                  </div>
                </div>
              ))}
            </div>
          </section>

          {/* Right column (fixture editor) */}
           <section className="w-[33%] bg-white p-4 rounded shadow">
            <div className="w-[100%]">
                <h2 className="font-semibold mb-2">Fikstür Düzenle</h2>
                <p className="text-xs text-gray-500 mb-2">Takım sayısına göre maç slotları oluşturulur (2'ye bölünebilen kısım).</p>

                <div className="space-y-2 max-h-60 overflow-auto mb-3">
                  {Array.from({length: Math.floor(teams.length/2)}).map((_, idx) => {
                    const a = fixtures[idx] ? fixtures[idx].a : null;
                    const b = fixtures[idx] ? fixtures[idx].b : null;
                    return (
                      <div key={idx} className="flex items-center gap-2">
                        <div className="w-12 text-sm font-semibold">Maç {idx+1}</div>
                        <select className="border rounded px-2 py-1 flex-1" value={a || ""} onChange={e=>{
                          const val = e.target.value || null;
                          setFixtures(prev => prev.map((f,i)=> i===idx ? {...f, a: val} : f));
                        }}>
                          <option value="">Takım 1 seç</option>
                          {teams.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
                        </select>
                        <select className="border rounded px-2 py-1 flex-1" value={b || ""} onChange={e=>{
                          const val = e.target.value || null;
                          setFixtures(prev => prev.map((f,i)=> i===idx ? {...f, b: val} : f));
                        }}>
                          <option value="">Takım 2 seç</option>
                          {teams.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
                        </select>
                        <button className="px-2 py-1 bg-indigo-600 text-white rounded text-sm" onClick={()=>{
                          // directly build one-match into matches and open it
                          const slot = fixtures[idx];
                          const aid = (slot && slot.a) || null;
                          const bid = (slot && slot.b) || null;
                          if (!aid || !bid) { alert('İki takımı seçin'); return; }
                          // add to matches if not exist
                          const exists = matches.find(m => m.a===aid && m.b===bid);
                          if (!exists) setMatches(prev => [...prev, { a: aid, b: bid }]);
                          openMatchByIndex(matches.length); // may be last — safer: find index after setMatches by computing
                          // but setMatches is async — instead we open by constructing an object and pushing synchronously into matches state:
                        }}>Ekle</button>
                      </div>
                    );
                  })}
                </div>

                <div className="flex gap-2">
                  <button className="px-3 py-1 bg-green-600 text-white rounded text-sm" onClick={buildMatchesFromFixtures}>Maçları Listele</button>
                  <button className="px-3 py-1 bg-gray-200 rounded text-sm" onClick={() => { setMatches([]); setActiveMatchIdx(null); }}>Temizle</button>
                </div>
              </div>
          </section>
       </div>

      {/* Right column (fixture editor + pitch placeholder) */}
      <div className="flex gap-6">

          {/* Fikstür listesi bölümü - SAHA ÖNİZLEME YANINA TAŞINDI */}
          <section className="w-[29%] bg-white p-4 rounded shadow">
            <h3 className="font-semibold mb-2">Fikstür Listesi</h3>
            <div className="space-y-2 max-h-[calc(100vh-100px)] overflow-auto mt-2">
              {matches.length===0 && <div className="text-sm text-gray-500">Henüz maç yok. Fikstürden oluşturun veya manuel ekleyin.</div>}
              {matches.map((m, idx) => {
                const ta = teams.find(t=>t.id===m.a);
                const tb = teams.find(t=>t.id===m.b);
                return (
                  <button key={idx} className={"w-full text-left border rounded px-3 py-2 " + (activeMatchIdx===idx ? "bg-indigo-50 border-indigo-300" : "hover:bg-gray-50")} onClick={()=>openMatchByIndex(idx)} disabled={!ta || !tb}>
                    <div className="flex items-center justify-between">
                      <div className="text-sm font-medium">Maç {idx+1}</div>
                      <div className="text-sm">
                        <span className="px-2 py-1 rounded text-white" style={{background: ta ? ta.color : '#999'}}>{ta ? ta.name : '---'}</span>
                        <span className="mx-2 text-gray-500">vs</span>
                        <span className="px-2 py-1 rounded text-white" style={{background: tb ? tb.color : '#999'}}>{tb ? tb.name : '---'}</span>
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
          </section>

        {/* Saha önizleme bölümü */}
        <section className="w-[70%] bg-white p-4 rounded shadow">
            <div className="flex items-start justify-between gap-4">
              {/* Pitch preview on the right inside this section */}
              <div className="w-[100%] pl-4">
                <h2 className="font-semibold mb-2">Saha Önizleme</h2>
                {! (activeMatchIdx !== null && matches[activeMatchIdx]) && <div className="text-sm text-gray-500">Maç listeden seçilmedi.</div>}
                { (activeMatchIdx !== null && matches[activeMatchIdx]) && (
                  <div className="space-y-3">
                    {/* Takım adları daha yakın konumlandırıldı */}
                    <div className="flex items-center justify-center gap-4 mb-4">
                      <div className="flex items-center gap-3">
                        <div className="w-4 h-4 rounded" style={{background: (teams.find(t=>t.id===matches[activeMatchIdx].a) || {}).color }}></div>
                        <div className="font-semibold text-lg">{ (teams.find(t=>t.id===matches[activeMatchIdx].a) || {}).name || 'Takım A' }</div>
                      </div>
                      <div className="text-lg font-bold text-gray-700 mx-2">VS</div>
                      <div className="flex items-center gap-3">
                        <div className="w-4 h-4 rounded" style={{background: (teams.find(t=>t.id===matches[activeMatchIdx].b) || {}).color }}></div>
                        <div className="font-semibold text-lg">{ (teams.find(t=>t.id===matches[activeMatchIdx].b) || {}).name || 'Takım B' }</div>
                      </div>
                    </div>

                    <div className="w-full h-[600px] halisaha rounded-lg relative overflow-hidden">
                      <svg viewBox="0 0 1000 600" className="w-full h-full">
                        <defs>
                          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="0" dy="2" stdDeviation="3" floodColor="#000" floodOpacity="0.4" />
                          </filter>
                        </defs>

                        <rect x="0" y="0" width="1000" height="600" fill="#1f7a2a" />
                        <rect x="40" y="30" width="920" height="540" fill="#2aa14a" rx="6" />
                        <line x1="500" y1="30" x2="500" y2="570" stroke="white" strokeWidth="2" strokeDasharray="8 6" />
                        <circle cx="500" cy="300" r="60" fill="none" stroke="white" strokeWidth="2" />
                        <rect x="40" y="210" width="120" height="180" fill="none" stroke="white" strokeWidth="2" />
                        <rect x="840" y="210" width="120" height="180" fill="none" stroke="white" strokeWidth="2" />
                        <rect x="40" y="30" width="920" height="540" fill="none" stroke="white" strokeWidth="3" />

                        {/* Players rendering for active match (A = left, B = right) */}
                        {(() => {
                          const mm = matches[activeMatchIdx];
                          if (!mm) return null;
                          const teamA = teams.find(t=>t.id===mm.a) || null;
                          const teamB = teams.find(t=>t.id===mm.b) || null;
                          return [
                            teamA ? renderTeamOnPitchFromMatch(teamA, true, 'A') : null,
                            teamB ? renderTeamOnPitchFromMatch(teamB, false, 'B') : null
                          ];
                        })()}

                      </svg>
                    </div>

                    <div className="flex gap-2">
                      <button className="px-3 py-1 bg-red-600 text-white rounded text-sm" onClick={()=>{ setActiveMatchIdx(null); }}>Maçı Kapat</button>
                      <button className="px-3 py-1 bg-gray-200 rounded text-sm" onClick={()=>{
                        // reset positions for this match
                        setMatchPositions(prev => {
                          const copy = {...prev};
                          delete copy[`match-${activeMatchIdx}`];
                          return copy;
                        });
                      }}>Pozisyonları Sıfırla</button>
                    </div>

                    <div className="text-xs text-gray-500">Oyuncuları sürükleyerek pozisyonlarını değiştirebilirsiniz. Konumlar maç bazında kaydedilir.</div>
                  </div>
                )}
               
              </div>
            </div>
          </section>
        </div>

        <footer className="mt-6 text-sm text-gray-500">
          Veriler tarayıcınızda saklanır (localStorage). Dışa/içe aktar ile yedekleyebilirsiniz.
        </footer>

        {/* --- Puan Giriş ve Görüntüleme Modalları --- */}
        { (showScoreInput || showScoreDisplay) && (
          <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4">
            <div className="bg-white rounded-lg p-6 shadow-xl w-[95vw] h-[95vh] overflow-y-auto">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-bold">{showScoreInput ? "Takım Puan Girişi" : "Kaydedilen Puanlar"}</h3>
                <button onClick={() => { setShowScoreInput(false); setShowScoreDisplay(false); }} className="text-gray-500 hover:text-gray-800 text-2xl font-bold">&times;</button>
              </div>
              
              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Takım</th>
                      <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Toplam Puan</th>
                      {Array.from({ length: numberOfMatchesPerTeam }).map((_, i) => (
                        <th key={i} scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Maç {i + 1}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {teams.map(team => {
                      const teamScores = scores[team.id] || {};
                      const totalScore = Object.values(teamScores).reduce((sum, current) => sum + (current || 0), 0);
                      return (
                        <tr key={team.id}>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{team.name}</td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 font-bold">{totalScore}</td>
                          {Array.from({ length: numberOfMatchesPerTeam }).map((_, i) => (
                            <td key={i} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                              {showScoreInput ? (
                                <input
                                  type="number"
                                  value={teamScores[i] === undefined ? '' : teamScores[i]}
                                  onChange={(e) => handleScoreChange(team.id, i, e.target.value)}
                                  className="border rounded w-20 text-center"
                                />
                              ) : (
                                teamScores[i] === undefined ? 0 : teamScores[i]
                              )}
                            </td>
                          ))}
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              
              <div className="mt-4 flex justify-end">
                <button onClick={() => { setShowScoreInput(false); setShowScoreDisplay(false); }} className="px-4 py-2 bg-indigo-600 text-white rounded">Kapat</button>
              </div>
            </div>
          </div>
        )}

      </div>
    );
  }

  // --- helper components used above (non-hook)
  function renderTeamOnPitchFromMatch(team, isLeft, sideKeyPrefix){
    // This function is defined inside App in original; we define wrapper here to call the App's functions via closure by adding it onto window temporarily.
    // But to keep things simple, we will NOT call hooks here; actual rendering is done inside App via its internal helper. 
    return null;
  }

  // We need to expose some helper functions into global so App can call them (renderPlayerCircle etc).
  // To avoid complex cross-scope issues, we'll attach required helpers to window and then reference them in App.
  window._halisaha_helpers = {
    getDefaultFormationPositions: function(isLeft){
      return {
        GK: { x: isLeft ? 120 : 880, y: 300 },
        DEF: [ { x: isLeft ? 220 : 780, y: 200 }, { x: isLeft ? 220 : 780, y: 400 } ],
        MID: [ { x: isLeft ? 400 : 600, y: 160 }, { x: isLeft ? 420 : 580, y: 300 }, { x: isLeft ? 400 : 600, y: 440 } ],
        FWD: { x: isLeft ? 520 : 480, y: 300 },
      };
    },
    shortName: function(name){
      if (!name) return "-";
      const parts = name.trim().split(/\s+/);
      if (parts.length === 1) return parts[0].slice(0,10);
      return (parts[0] + " " + parts[parts.length-1]).slice(0,12);
    }
  };

  // Because the renderTeamOnPitchFromMatch and renderPlayerCircle were closures in previous version,
  // we need to mount a final component that contains those helpers properly. For simplicity and reliability,
  // we'll render App now, where App defines its own renderTeamOnPitchFromMatch & renderPlayerCircle in its scope
  // (the implementation above does that). So we just mount App.
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
  </script>
</body>
</html>